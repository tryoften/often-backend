{"version":3,"sources":["app/Services/ServiceBase.js"],"names":[],"mappings":";;;;;;;;;;;;0CAA4B,gCAAgC;;;;;;;;;;IAOtD,WAAW;;;;;;;;;;AAUJ,UAVP,WAAW,CAUH,MAAM,EAAE,IAAI,EAAE;wBAVtB,WAAW;;AAYf,MAAI,CAAC,SAAS,GAAG,MAAM,CAAC,SAAS,CAAC;AAClC,MAAI,CAAC,WAAW,GAAG,IAAI,CAAC,aAAa,CAAC;AACtC,MAAI,CAAC,cAAc,GAAG,IAAI,CAAC,cAAc,IAAI,KAAK,CAAC;AACnD,MAAI,CAAC,eAAe,GAAG,4CAAoB,EAAC,QAAQ,EAAG,IAAI,CAAC,aAAa,EAAC,CAAC,CAAC;EAE5E;;cAjBI,WAAW;;;;;;;;;SA0BR,iBAAC,OAAO,EAAE;;;AAEjB,OAAI,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;AACjC,OAAI,SAAS,GAAG,OAAO,CAAC,EAAE,CAAC;;;AAG3B,OAAI,CAAC,eAAe,CAAC,IAAI,CAAC,MAAM,EAAE,UAAC,EAAE,EAAK;;;AAGzC,QAAI,MAAK,eAAe,CAAC,YAAY,CAAC,MAAK,cAAc,EAAE,KAAK,CAAC,EAAE;;;AAGlE,SAAI,OAAO,GAAG,MAAK,eAAe,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;AACrD,YAAO,CAAC,GAAG,CAAC,wBAAwB,CAAC,CAAC;AACtC,YAAO,CAAC,GAAG,CAAC,eAAe,GAAG,OAAO,CAAC,CAAC;AACvC,WAAK,SAAS,CAAC,cAAc,CAAC,SAAS,EAAE,MAAK,WAAW,EAAE,OAAO,CAAC,CAAC;KAEpE,MAAM;AACN,YAAO,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;;AAEzB,WAAK,SAAS,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,UAAC,OAAO,EAAK;;;AAGvC,UAAI,QAAQ,GAAG,MAAK,SAAS,CAAC,cAAc,CAAC,SAAS,EAAE,MAAK,WAAW,EAAE,OAAO,CAAC,CAAC;AACnF,YAAK,eAAe,CAAC,aAAa,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;MAEpD,CAAC,CAAC;KAEH;IAED,CAAC,CAAC;;;AAGH,OAAI,CAAC,eAAe,CAAC,KAAK,EAAE,CAAC;GAC7B;;;QA5DI,WAAW;;;qBA+DF,WAAW","file":"app/Services/ServiceBase.js","sourcesContent":["import CachedResponses from '../Collections/CachedResponses';\n\n/** \n *\tThis class is a base class for all service providers. \n *\tIt has an instance of the results collection to which it adds a response after processing.\n *\tIt also keeps tracks of a cache for the derived class's responses.\n */\nclass ServiceBase {\n\n\n\t/**\n\t * Initializes the service base.\n\t * @param {object} models - supporting models\n\t * @param {object} opts - supporting options\n\t *\n\t * @return {Void}\n\t */\n\tconstructor (models, opts) {\n\n\t\tthis.responses = models.responses;\n\t\tthis.provider_id = opts.provider_name;\n\t\tthis.fetch_interval = opts.fetch_interval || 30000; //30 second default\n\t\tthis.cachedResponses = new CachedResponses({provider : opts.provider_name});\n\n\t}\n\n\n\t/**\n\t * Method for executing a request with a service provider.\n\t * @param {object} request - request to be processed\n\t *\n\t * @return {Void}\n\t */\n\texecute (request) {\n\n\t\tvar query = request.get('query');\n\t\tvar requestId = request.id;\n\n\t\t/* Sync the cache */\n\t\tthis.cachedResponses.once('sync', (cr) => {\n\n\t\t\t/* Check if the cache for the query is valid */\n\t\t\tif (this.cachedResponses.isCacheValid(this.fetch_interval, query)) {\n\n\t\t\t\t/* If so create a response based off of cached results */\n\t\t\t\tvar results = this.cachedResponses.getResults(query);\n\t\t\t\tconsole.log('about to print results');\n\t\t\t\tconsole.log('results are: ' + results);\n\t\t\t\tthis.responses.createResponse(requestId, this.provider_id, results);\n\n\t\t\t} else {\n\t\t\t\tconsole.log('non cache');\n\t\t\t\t/* Otherwise refresh the cache by obtaining new data from derived class via fetchData method */\n\t\t\t\tthis.fetchData(query).then((results) => {\n\n\t\t\t\t\t/* Create a response based off of returned results and update the cache */\n\t\t\t\t\tvar response = this.responses.createResponse(requestId, this.provider_id, results);\n\t\t\t\t\tthis.cachedResponses.cacheResponse(query, response);\n\n\t\t\t\t});\n\n\t\t\t}\n\n\t\t});\n\n\t\t/* Force the sync event to occur in case the cache is empty */\n\t\tthis.cachedResponses.fetch();\t\n\t}\n}\n\nexport default ServiceBase;"]}