{"version":3,"sources":["app/Services/ServiceBase.js"],"names":[],"mappings":";;;;;;;;;;;;0CAA4B,gCAAgC;;;;;;;;;;IAQtD,WAAW;;;;;;;;AAQJ,UARP,WAAW,CAQH,MAAM,EAAE,IAAI,EAAE;wBARtB,WAAW;;AAUf,MAAI,CAAC,SAAS,GAAG,MAAM,CAAC,SAAS,CAAC;AAClC,MAAI,CAAC,WAAW,GAAG,IAAI,CAAC,aAAa,CAAC;AACtC,MAAI,CAAC,cAAc,GAAG,IAAI,CAAC,cAAc,IAAI,KAAK,CAAC;AACnD,MAAI,CAAC,eAAe,GAAG,4CAAoB,EAAC,QAAQ,EAAG,IAAI,CAAC,aAAa,EAAC,CAAC,CAAC;EAE5E;;cAfI,WAAW;;;;;;;;;;;SAyBR,iBAAC,OAAO,EAAE;;;AAEjB,OAAI,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;AACjC,OAAI,SAAS,GAAG,OAAO,CAAC,EAAE,CAAC;;;AAG3B,OAAI,CAAC,eAAe,CAAC,IAAI,CAAC,MAAM,EAAE,UAAC,EAAE,EAAK;;;AAGzC,QAAI,MAAK,eAAe,CAAC,YAAY,CAAC,MAAK,cAAc,EAAE,KAAK,CAAC,EAAE;;;AAGlE,SAAI,OAAO,GAAG,MAAK,eAAe,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;AACrD,WAAK,SAAS,CAAC,cAAc,CAAC,SAAS,EAAE,MAAK,WAAW,EAAE,OAAO,CAAC,CAAC;KAEpE,MAAM;;;AAGN,WAAK,SAAS,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,UAAC,OAAO,EAAK;;;AAGvC,UAAI,QAAQ,GAAG,MAAK,SAAS,CAAC,cAAc,CAAC,SAAS,EAAE,MAAK,WAAW,EAAE,OAAO,CAAC,CAAC;AACnF,YAAK,eAAe,CAAC,aAAa,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;MAEpD,CAAC,CAAC;KAEH;IAED,CAAC,CAAC;;;AAGH,OAAI,CAAC,eAAe,CAAC,KAAK,EAAE,CAAC;GAC7B;;;QAzDI,WAAW;;;qBA4DF,WAAW","file":"app/Services/ServiceBase.js","sourcesContent":["import CachedResponses from '../Collections/CachedResponses';\n\n/* \n\tThis class is a base class for all service providers. \n\tIt has an instance of the results collection to which it adds a response after processing.\n\tIt also keeps tracks of a cache for the derived class's responses.\n*/\n\nclass ServiceBase {\n\n\t/* \n\t\tDescription: Initializes the service base.\n\t\tParameters: Models (supporting models), options (supporting options)\n\t\tSignature: (Object, Object) -> Void\n\t*/\n\n\tconstructor (models, opts) {\n\n\t\tthis.responses = models.responses;\n\t\tthis.provider_id = opts.provider_name;\n\t\tthis.fetch_interval = opts.fetch_interval || 30000; //30 second default\n\t\tthis.cachedResponses = new CachedResponses({provider : opts.provider_name});\n\n\t}\n\n\t/* \n\t\tDescription: \n\t\t\tIf response for the request has been cached and the cache for that response is still valid, then cached response is returned.\n\t\t\tElse, the request is processed in the derived class, the cache of the response is updated, and a new response is returned.\n\t\tParameter: Datetime in milliseconds from the start of the epoch.\n\t\tSignature: (Object) -> Void\n\t*/\n\n\texecute (request) {\n\n\t\tvar query = request.get('query');\n\t\tvar requestId = request.id;\n\n\t\t/* Sync the cache */\n\t\tthis.cachedResponses.once('sync', (cr) => {\n\n\t\t\t/* Check if the cache for the query is valid */\n\t\t\tif (this.cachedResponses.isCacheValid(this.fetch_interval, query)) {\n\n\t\t\t\t/* If so create a response based off of cached results */\n\t\t\t\tvar results = this.cachedResponses.getResults(query);\n\t\t\t\tthis.responses.createResponse(requestId, this.provider_id, results);\n\n\t\t\t} else {\n\n\t\t\t\t/* Otherwise refresh the cache by obtaining new data from derived class via fetchData method */\n\t\t\t\tthis.fetchData(query).then((results) => {\n\n\t\t\t\t\t/* Create a response based off of returned results and update the cache */\n\t\t\t\t\tvar response = this.responses.createResponse(requestId, this.provider_id, results);\n\t\t\t\t\tthis.cachedResponses.cacheResponse(query, response);\n\n\t\t\t\t});\n\n\t\t\t}\n\n\t\t});\n\n\t\t/* Force the sync event to occur in case the cache is empty */\n\t\tthis.cachedResponses.fetch();\t\n\t}\n}\n\nexport default ServiceBase;"]}