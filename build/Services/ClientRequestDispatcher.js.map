{"version":3,"sources":["app/Services/ClientRequestDispatcher.js"],"names":[],"mappings":";;;;;;;;;;;;mCAAqB,yBAAyB;;;;oCACxB,0BAA0B;;;;qCACrB,0BAA0B;;;;gCACnC,sBAAsB;;;;;;;;;IAOlC,uBAAuB;;;;;;;;AAQhB,UARP,uBAAuB,CAQf,MAAM,EAAE,IAAI,EAAE;wBARtB,uBAAuB;;AAU3B,MAAI,CAAC,QAAQ,GAAG,sCAAc,CAAC;AAC/B,MAAI,CAAC,SAAS,GAAG,uCAAe,CAAC;AACjC,MAAI,CAAC,gBAAgB,GAAG,EAAE,CAAC;AAC3B,MAAI,CAAC,gBAAgB,CAAC,OAAO,GAAG,uCAAmB,EAAC,SAAS,EAAG,IAAI,CAAC,SAAS,EAAC,CAAC,CAAC;AACjF,MAAI,CAAC,KAAK,GAAG,mCAAW,CAAC;EAEzB;;cAhBI,uBAAuB;;;;;;;;;SAwBpB,mBAAG;;;;AAGV,OAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,UAAC,CAAC,EAAK;;;AAG9B,UAAK,QAAQ,CAAC,EAAE,CAAC,KAAK,EAAE,UAAC,eAAe,EAAK;;;AAG5C,SAAI,OAAO,GAAG,eAAe,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;AAC1C,SAAI,cAAc,GAAG,MAAK,KAAK,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;;;AAG9D,WAAM,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,OAAO,CAAC,UAAC,YAAY,EAAK;;;AAGrD,UAAG,CAAC,MAAK,gBAAgB,CAAC,YAAY,CAAC,EAAE;;AAExC,cAAO,CAAC,GAAG,CAAC,wDAAwD,GAAG,YAAY,CAAC,CAAC;OAErF,MAAM;;;AAGN,cAAO,CAAC,GAAG,CAAC,wBAAwB,CAAC,CAAC;AACtC,aAAK,gBAAgB,CAAC,YAAY,CAAC,CAAC,OAAO,CAAC,eAAe,CAAC,CAAC;OAE7D;MAED,CAAC,CAAC;KAEH,CAAC,CAAC;IAEH,CAAC,CAAC;GAEH;;;QA1DI,uBAAuB;;;qBA6Dd,uBAAuB","file":"app/Services/ClientRequestDispatcher.js","sourcesContent":["import Requests from '../Collections/Requests';\nimport Responses from '../Collections/Responses';\nimport SpotifyService from './Spotify/SpotifyService';\nimport Users from '../Collections/Users';\n\n/*\n\tThis class is responsible for figuring out which service provider must handle a given incoming request.\n\tThis class calls the 'execute' method of an appropriate service provider (as per request) and keeps track of the response.\n*/\n\nclass ClientRequestDispatcher {\n\n\t/* \n\t\tDescription: Initializes the cached responses collection.\n\t\tParameters: Models (supporting models), options (supporting options)\n\t\tSignature: (Object, Object) -> Void\n\t*/\n\n\tconstructor (models, opts) {\n\n\t\tthis.requests = new Requests();\n\t\tthis.responses = new Responses();\n\t\tthis.serviceProviders = {};\n\t\tthis.serviceProviders.spotify = new SpotifyService({responses : this.responses});\n\t\tthis.users = new Users();\n\t\t\n\t}\n\n\t/* \n\t\tDescription: Determines which service provider the request should be executed with and executes it.\n\t\tParameters: Models (supporting models), options (supporting options)\n\t\tSignature: () -> Void\n\t*/\n\n\tprocess () {\n\n\t\t/* Sync up the user collection to retrieve a list of all users and the servides they are subscribed to */\n\t\tthis.users.once('sync', (x) => {\n\n\t\t\t/* Set up an event listener for new requests */\n\t\t\tthis.requests.on('add', (incomingRequest) => {\n\t\t\t\t\n\t\t\t\t/* Obtain a list of all the providers the user is subscribed to */\n\t\t\t\tvar user_id = incomingRequest.get('user');\n\t\t\t\tvar user_providers = this.users.get(user_id).get('providers');\n\n\t\t\t\t/* For every user provider that the user is subscribed to */\n\t\t\t\tObject.keys(user_providers).forEach((providerName) => {\n\n\t\t\t\t\t/* In the unlikely event that the provider for the user request is not found, just write to stdout */\n\t\t\t\t\tif(!this.serviceProviders[providerName]) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tconsole.log(\"No service handlers found for the following provider: \" + providerName);\n\t\t\t\t\t\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t/* If the provider is found, then execute the incoming request using the instance of an appropriate provider handler */\n\t\t\t\t\t\tconsole.log('Provider handler found');\n\t\t\t\t\t\tthis.serviceProviders[providerName].execute(incomingRequest);\n\t\t\t\t\t\n\t\t\t\t\t}\n\n\t\t\t\t});\n\n\t\t\t});\n\n\t\t});\n\n\t}\n}\n\nexport default ClientRequestDispatcher;"]}